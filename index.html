
  <!DOCTYPE html>
  <html>
  <head>
  <meta charset='utf-8'>
  <title>SPM Linux</title>
  
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css'>
  <style>
    body {
      padding: 2px;
      margin: 0;
      font-family: Hack;
      font-size: 11ppt;
      color: #222222;
      white-space: pre;
      tab-size: 4;
    }
  </style>
  </head><body><a href='https://github.com/damoonsaghian/SPM-Linux'><h1>SPM Linux</h1></a>
<h2>1, computers</h2><div>computers can help people to easily access and improve human knowledge,</div><div>	and as a result do things to improve the quality of human life</div><div><p></p></div><div>computers must be portable devices with a USBC (USB4 without PCIe) port,</div><div>	which connects to a display and also provides power</div><div>ports on the display: USB dock, ethernet, audio jack, DP and HDMI</div><div>the display also has speakers, camera, light sensor and auto brightness</div><div>the computer itself should also include those mentioned extra ports,</div><div>	for situation that such a display is not available</div><div><p></p></div><div><b>digital circuits</b></div><div>in conventional digital circuits when the inputs change, the outputs can have temporary invalid values,</div><div>	until they stabilize to the valid values</div><div>but for the circuit to do its job, gates with memory (registers),</div><div>	must operate only when the inputs have correct values</div><div>one solution is to synchronize registers with a global clock signal</div><div>	the period of clock signal is made long enough for the circuit to become stable</div><div><p></p></div><div>disadvantages of synchronous circuits:</div><div>, we have to split long operations into several smaller ones,</div><div>	which can be performed in successive clock cycles (a technique known as pipelining)</div><div>	otherwise the circuit would be slow and inefficient</div><div>, distributing a high'fan'out, timing'sensitive clock signal can be complicated</div><div>, electromagnetic interference at the clock frequency and its harmonics</div><div>, widely distributed clock signal takes a lot of power, and must run whether the circuit is receiving inputs or not</div><div>although "clock gating" can help to reduce some of the problems of synchronous circuits,</div><div>	i think the real solution is to use asynchronous circuits</div><div><p></p></div><div>the only sane kind of asynchronous circuit which i could imagine is this:</div><div>, next to any data wire, there is a control wire which determines if the data is valid or not</div><div>, when a register wants to change its outputs, it first invalidates them,</div><div>	for a duration equal to the delay of one gate</div><div>, any gate receiving an invalid input, invalidates its outputs</div><div>, this way all data which is going to change in the future, is first invalidated</div><div>, registers operate only when all inputs are valid</div><div><p></p></div><div><b>computer architecture</b></div><div>cpu, memory, peripherals, this seems to be the only practical architecture for the hardware of computers</div><div>cpu runs a sequence of simple computations, called instruction codes, one by one</div><div>compilers are special programs that generate instruction codes,</div><div>	from a program written in a structured and human readable language</div><div><a href='https://www.bottomupcs.com/'>https://www.bottomupcs.com/</a></div><div><p></p></div><div>there is always the possibility of backdoors for closed source CPU,</div><div>	especially if the boot firmware is also closed source</div><div>recently introduction of "secure execution environment" makes this situation even worse</div><div>it's a closed source, full'blown, always'running mini operating system,</div><div>	with full access to the whole system (including memory and network)</div><div>furthermore they have made it practically impossible for users to disable it</div><div>this mess of a design cries out for hidden and quite sophisticated backdoors</div><div><a href='https://www.fsf.org/blogs/licensing/intel-me-and-why-we-should-get-rid-of-me'>https://www.fsf.org/blogs/licensing/intel-me-and-why-we-should-get-rid-of-me</a></div><div><a href='https://libreboot.org/faq.html#intel'>https://libreboot.org/faq.html#intel</a></div><div><a href='https://en.wikipedia.org/wiki/Intel_Management_Engine'>https://en.wikipedia.org/wiki/Intel_Management_Engine</a></div><div><a href='https://blog.invisiblethings.org/papers/2015/x86_harmful.pdf'>https://blog.invisiblethings.org/papers/2015/x86_harmful.pdf</a></div><div><p></p></div><div>on X86 architectures the default boot firmware on nearly all systems are closed source</div><div>flashing a CoreBoot based boot firmware is possible, but there still will be closed source parts (Intel FSP)</div><div>in addition, there is no easy way to get rid of Intel ME (or AMD PSP),</div><div>	though there are some hacks to disable (but not completely remove) it:</div><div>	<a href='https://puri.sm/posts/deep-dive-into-intel-me-disablement/'>https://puri.sm/posts/deep-dive-into-intel-me-disablement/</a></div><div><p></p></div><div>ARM architecture is closed source too, but in most cases, boot firmwares are open source (U-Boot or EDK2)</div><div>ARM TrustZone can host an open source operating system too, apparently:</div><div>	<a href='https://news.ycombinator.com/item?id=17783357'>https://news.ycombinator.com/item?id=17783357</a></div><div>GPU with open source driver: Qualcomm/Adreno</div><div><p></p></div><div>open source CPU: RISC-V, Power ISA</div><div><p></p></div><div>boot firmware must have a read'only part and an updatable part</div><div>this way an interrupted flashing does not brick the device</div><div>also the read'only part checks the signature of the updatable part, to make sure it's not malicious</div><div><p></p></div><div>programs usually do not run directly on computer hardware</div><div>instead they run on a more sophisticated software machine (a virtual machine) called the kernel</div><div>in theory we can live without a kernel (an idea sometimes called a library operating system),</div><div>	and it can be useful for some use cases (like IoT devices),</div><div>	but a kernel based operating system makes developing and testing programs, much easier</div><div>Linux is a highly developed, constantly evolving, open'source kernel</div>
<h2>2, SPM Linux</h2><div>SPM Linux is a Linux based operating system, built and maintained using SPM (simple package manager)</div><div>SPM uses a simple and innovative method that unifies software building and package management,</div><div>	as will be explained in the next chapter</div><div><p></p></div><div>to install SPM Linux, first we need to be in a Posix compliant system, with these programs installed:</div><div>	fdisk mkfs.vfat mkfs.btrfs gcc g++ git gnunet</div><div>for example you can boot into an Alpine Linux live system, then:</div><div>; apt add btrfs-progs gcc g++ git gnunet</div><div>then run this in a terminal:</div><div>; sudo sh install.sh</div><div><p></p></div><div>the user interface of SPM Linux is very simple</div><div>press "super" (mod+mod) or "alt+tab" to show the application launcher</div><div>press "super" or "alt+tab" again to go to previously viewed application (if any)</div><div>the first item in application launcher is "system"; it opens the system menu:</div><div>	, session (lock, suspend, exit, reboot, poweroff)</div><div>	, connections</div><div>	, timezone</div><div>	, password</div><div>	, packages</div><div>press "super+backspace" or "alt+escape" to close a window</div><div><p></p></div><div>the package management process is atomic</div><div>nonetheless, to have a really fail'safe system, redundant backups are necessary</div><div>to create a portable SPM Linux for emergency, go to "system -&gt; packages -&gt; create a portable SPM Linux"</div><div>this can also be used to create a cross'compiled SPM Linux</div><div><p></p></div><div>to run a program as root:</div><div>; sudo command</div><div>this will run a program in virtual terminal 7, that shows the command at the top, and asks for root password,</div><div>	and when "enter" is pressed, returns back to previous virtual terminal</div><div>press F5 (or F6 or F7 or F8) to go to virtual terminal 7, where one can give root password</div><div>if the user is in "sudo" group and the entered password is correct, it runs the command as root</div><div>this means that if a malicious program can't steal root password (eg by faking sudo password entry)</div><div>and to enter root password, physical access is necessary,</div><div>	because there is no other way to enter the password in a virtual terminal</div><div>take a look at these:</div><div><a href='https://www.reddit.com/r/linuxquestions/comments/8mlil7/whats_the_point_of_the_sudo_password_prompt_if/'>https://www.reddit.com/r/linuxquestions/comments/8mlil7/whats_the_point_of_the_sudo_password_prompt_if/</a></div><div><a href='https://security.stackexchange.com/questions/119410/why-should-one-use-sudo'>https://security.stackexchange.com/questions/119410/why-should-one-use-sudo</a></div><div>note that it's not possible to login as root; root account is locked</div><div><p></p></div><div>to protect the computer from physical attacks, don't leave the computer with an unlocked session</div><div>in addition you must:</div><div>, somehow prevent tampering with hardware</div><div>, protect boot firmware by a password</div><div>, disable changing the storage device used for booting</div><div>these can make physical attacks more difficult, but keep this in mind:</div><div>	physical access to a computer is root access, given enough time and resources</div>
<h2>3, SPM</h2><div>SPM packages are simple source code directories containing a "spmbuild.sh" file</div><div>"spmbuild.sh" is a shell script file with special comment lines:</div><div>	#dep &lt;gnu-url|package-name&gt;</div><div>if "spm" is run as root, "spmbuild.sh" files will be run in a namespace, using "unshare"</div><div>	<a href='https://en.wikipedia.org/wiki/Linux_namespaces'>https://en.wikipedia.org/wiki/Linux_namespaces</a></div><div>	<a href='https://git.busybox.net/busybox/tree/util-linux/unshare.c'>https://git.busybox.net/busybox/tree/util-linux/unshare.c</a></div><div>	<a href='https://manpages.debian.org/bookworm/util-linux/unshare.1.en.html'>https://manpages.debian.org/bookworm/util-linux/unshare.1.en.html</a></div><div>	<a href='https://github.com/containers/bubblewrap'>https://github.com/containers/bubblewrap</a></div><div><p></p></div><div>the "spmbuild.sh" file can be in a gnunet URL</div><div>the source can be in the same place, or in a Git URL (in which case it will git'cloned in the spmbuild file)</div><div>when a package is published:</div><div>, the source is published to gnunet://&lt;domain-name&gt;/packages/src/&lt;package-name&gt;/</div><div>, the files ".cache/spm/&lt;arch&gt;/" (not recursively) will be put into:</div><div>	gnunet://&lt;domain-name&gt;/packages/&lt;arch&gt;/&lt;package-name&gt;/</div><div><p></p></div><div>when downloading a dep, if the a built one for the arch exist,</div><div>	just download that (and put it in .cache/spm/&lt;arch&gt;/) plus the spmbuild.sh file,</div><div>	otherwise download the whole source</div><div><p></p></div><div>"spm" program puts all output files in ".cache/spm" under the source code directory</div><div>SPM packages do not need dependency tracking</div><div>because all the dependencies will be hard'linked to the application's directory</div><div><p></p></div><div>to build a package (including deps):</div><div>this downloads the source code from the given URL into "$spm_dir/packages/&lt;url-hash&gt;",</div><div>	then builds the package using "$spm_dir/packages/&lt;url-hash&gt;/spmbuild"</div><div>	("$spm_dir" is "/spm" when "spm" is run as root, and "~/.local/spm" otherwise)</div><div>when instead of a URL, a package name is given,</div><div>	it just builds a package that already exists in "$spm_dir/packages/&lt;package-name&gt;"</div><div>	this happens for builtin or customized packages</div><div><p></p></div><div>to install a package:</div><div>; spm install &lt;package-name&gt; [&lt;url&gt;]</div><div>this command:</div><div>, builds the package (as explained above)</div><div>, creates hard links from files in "$spm_dir/packages/&lt;url-hash|package-name&gt;/.cache/spm/&lt;arch&gt;" directory,</div><div>	into "$spm_dir/installed/&lt;package-name&gt;" directory (recursively)</div><div>, if a URL is given, put it in "$spm_dir/installed/&lt;package-name&gt;/data/url" file</div><div>	later this will be used to update the app</div><div>, creates symlinks from files mentioned in "$spm_dir/installed/&lt;package-name&gt;/data/apps" file,</div><div>	into "$apps_dir" directory</div><div>	("$apps_dir" is "/apps" when "spm" is run as root, and "~/.local/bin" otherwise)</div><div>, creates symlinks from "$spm_dir/installed/&lt;package-name&gt;/data/*.desktop" files into "$gui_apps_dir"</div><div>	("$gui_apps_dir" is "/apps/gui" when "spm" is run as root, and "~/.local/share/applications" otherwise)</div><div><p></p></div><div>public keys for a package downloaded from a URL can be stored in "$spm_dir/keys/&lt;url-hash&gt;"</div><div>spm uses these keys to check the signature of packages when downloading/updating them</div><div><p></p></div><div>if you want to customize the configurations of an SPM package:</div><div>, create "$spm_dir/packages/&lt;package-name&gt;/spmbuild.sh" containing:</div><div>	, build command for the package we want to customize: spm build &lt;url&gt;</div><div>	, commands to hard link the required files</div><div>	, commands to apply the custom configurations</div><div>, run "spm install &lt;package-name&gt;"</div><div>this way to customize packages, without the need for "/etc"</div><div><p></p></div><div>to remove an installed app:</div><div>; spm remove &lt;package-name&gt;</div><div>this command:</div><div>, removes the files mentioned in "$spm_dir/installed/&lt;package-name&gt;/data/apps" from "/apps"</div><div>, removes files in "/apps/gui/" corresponding to "$spm_dir/installed/&lt;package-name&gt;/data/*.desktop"</div><div>, removes "$spm_dir/installed/&lt;package-name&gt;" directory</div></body></html>