<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<title>SPM Linux</title>
<link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css'>
<style>
body {
	padding: 4px;
	margin: 0;
	font-family: Hack;
	font-size: 11ppt;
	color: #222222;
	white-space: pre;
	tab-size: 4;
}
</style>
</head><body><a href='https://github.com/damoonsaghian/SPM-Linux'><h1>SPM Linux</h1></a>
<h2>1, computers</h2><div>computers can help people to easily access and improve human knowledge,
</div><div>	and as a result do things to improve the quality of human life
</div><div>
</div><div><b>digital circuits</b>
</div><div>in conventional digital circuits when the inputs change, the outputs can have temporary invalid values,
</div><div>	until they stabilize to the valid values
</div><div>but for the circuit to do its job, gates with memory (registers),
</div><div>	must operate only when the inputs have correct values
</div><div>one solution is to synchronize registers with a global clock signal
</div><div>	the period of clock signal is made long enough for the circuit to become stable
</div><div>
</div><div>disadvantages of synchronous circuits:
</div><div>, we have to split long operations into several smaller ones,
</div><div>	which can be performed in successive clock cycles (a technique known as pipelining)
</div><div>	otherwise the circuit would be slow and inefficient
</div><div>, distributing a high'fan'out, timing'sensitive clock signal can be complicated
</div><div>, electromagnetic interference at the clock frequency and its harmonics
</div><div>, widely distributed clock signal takes a lot of power, and must run whether the circuit is receiving inputs or not
</div><div>although "clock gating" can help to reduce some of the problems of synchronous circuits,
</div><div>	i think the real solution is to use asynchronous circuits
</div><div>
</div><div>the only sane kind of asynchronous circuit which i could imagine is this:
</div><div>, next to any data wire, there is a control wire which determines if the data is valid or not
</div><div>, when a register wants to change its outputs, it first invalidates them,
</div><div>	for a duration equal to the delay of one gate
</div><div>, any gate receiving an invalid input, invalidates its outputs
</div><div>, this way all data which is going to change in the future, is first invalidated
</div><div>, registers operate only when all inputs are valid
</div><div>
</div><div><b>computer architecture</b>
</div><div>cpu, memory, peripherals, this seems to be the only practical architecture for the hardware of computers
</div><div>cpu runs a sequence of simple computations, called instruction codes, one by one
</div><div>compilers are special programs that generate instruction codes,
</div><div>	from a program written in a structured and human readable language
</div><div><a href="https://www.bottomupcs.com/">https://www.bottomupcs.com/</a>
</div><div>
</div><div>there is always the possibility of backdoors for closed source CPU,
</div><div>	especially if the boot firmware is also closed source
</div><div>recently introduction of "secure execution environment" makes this situation even worse
</div><div>it's a closed source, full'blown, always'running mini operating system,
</div><div>	with full access to the whole system (including memory and network)
</div><div>furthermore they have made it practically impossible for users to disable it
</div><div>this mess of a design cries out for hidden and quite sophisticated backdoors
</div><div><a href="https://www.fsf.org/blogs/licensing/intel-me-and-why-we-should-get-rid-of-me">https://www.fsf.org/blogs/licensing/intel-me-and-why-we-should-get-rid-of-me</a>
</div><div><a href="https://libreboot.org/faq.html#intel">https://libreboot.org/faq.html#intel</a>
</div><div><a href="https://en.wikipedia.org/wiki/Intel_Management_Engine">https://en.wikipedia.org/wiki/Intel_Management_Engine</a>
</div><div><a href="https://blog.invisiblethings.org/papers/2015/x86_harmful.pdf">https://blog.invisiblethings.org/papers/2015/x86_harmful.pdf</a>
</div><div>
</div><div>on X86 architectures the default boot firmware on nearly all systems are closed source
</div><div>flashing a CoreBoot based boot firmware is possible, but there still will be closed source parts (Intel FSP)
</div><div>in addition, there is no easy way to get rid of Intel ME (or AMD PSP),
</div><div>	though there are some hacks to disable (but not completely remove) it:
</div><div>	<a href="https://puri.sm/posts/deep-dive-into-intel-me-disablement/">https://puri.sm/posts/deep-dive-into-intel-me-disablement/</a>
</div><div>
</div><div>ARM architecture is closed source too, but in most cases, the boot firmware is open source (U-Boot or EDK2)
</div><div>ARM TrustZone can host an open source operating system too, apparently:
</div><div>	<a href="https://news.ycombinator.com/item?id=17783357">https://news.ycombinator.com/item?id=17783357</a>
</div><div>GPU with open source driver: Qualcomm/Adreno
</div><div>
</div><div>open source CPU: RISC-V, Power ISA
</div><div>
</div><div>boot firmware must have a read'only part and an updatable part
</div><div>this way an interrupted flashing does not brick the device
</div><div>also the read'only part checks the signature of the updatable part, to make sure it's not malicious
</div><div>the read'only part just executes the updatable part, if o keys are pressed
</div><div>
</div><div>to protect the computer from physical attacks, you must:
</div><div>, somehow prevent tampering with hardware
</div><div>, protect boot firmware settings by a password
</div><div>	to prevent changing the storage device used for booting
</div><div>these can make physical attacks more difficult, but keep in mind that:
</div><div>	physical access to a computer is root access, given enough time and resources
</div><div>even with encrypted root partition, and secure boot, someone can replace RAM with a malicious chip,
</div><div>	that can discover the key used to encrypt the root partition (very sophisticated but not impossible)
</div><div>so it's best to make computers as small as possible, so they can always be kept near the owner
</div><div>the ideal computer would be a PC stick, containing a RISC-V processor, GPU, RAM and SSD,
</div><div>	plus a USB4 2.0 port that connects to a hub
</div><div>the hub:
</div><div>, provides power
</div><div>, has a USB dock (to connect peripherals like display and camera)
</div><div>, wifi, Bluetooth, maybe even speaker and microphone
</div><div>, extra ports: ethernet, audio jack, DP and HDMI
</div><div>for security reasons, th PCIe tunnel of USB4 2.0 will be disabled in boot firmware
</div><div>	<a href="https://www.chromium.org/chromium-os/developer-library/reference/security/usb4/">https://www.chromium.org/chromium-os/developer-library/reference/security/usb4/</a>
</div><div>	<a href="https://en.wikipedia.org/wiki/Thunderbolt_(interface)#Security_vulnerabilities">https://en.wikipedia.org/wiki/Thunderbolt_(interface)#Security_vulnerabilities</a>
</div><div>external graphic cards should allow direct connection to the display (bypassing GPU),
</div><div>	if the USB4 connection does not have a PCIe tunnel
</div><div>
</div><div>programs usually do not run directly on computer hardware
</div><div>instead they run on a more sophisticated software machine (a virtual machine) called the kernel
</div><div>in theory we can live without a kernel (an idea sometimes called a library operating system),
</div><div>	and it can be useful for some use cases (like embedded systems),
</div><div>	but a kernel based operating system makes developing and testing programs, much easier
</div><div>Linux is a highly developed, constantly evolving, open'source kernel
</div>
<h2>2, SPM Linux</h2><div>SPM Linux is a Linux based operating system, built and maintained using SPM (simple package manager)
</div><div>SPM uses a simple and innovative method that unifies software building and package management
</div><div>
</div><div>SPM by itself can be used as a standalone build system and package manager on any POSIX system
</div><div>you need to have "gnunet" program on your system
</div><div>also to build packages from source, these extra programs are required:
</div><div>	clang git ssh-keygen
</div><div>now just run this command to install SPM in user's home directory:
</div><div>; sh spm/install.sh
</div><div>note that SPM will try to download binary packages (instead of building from source),
</div><div>	if they are available for your system
</div><div>if you want to make sure that packages are always built from source, run this instead:
</div><div>; sh spm/install.sh src
</div><div>
</div><div>to install SPM Linux on a storage device, first we need to be in a POSIX system with these programs installed:
</div><div>	gnunet mkfs.vfat mkfs.btrfs
</div><div>to build packages from source, these extra programs are required too:
</div><div>	clang git ssh-keygen
</div><div>for example you can boot into an Alpine Linux live system, and enter this at the command line:
</div><div>; setup-interfaces
</div><div>; apk add gnunet btrfs-progs
</div><div>or if you want to build packages from source:
</div><div>; apk add gnunet btrfs-progs clang git openssh-keygen
</div><div>now just run this command (as root):
</div><div>; sh spm/install.sh
</div><div>or to build packages from source:
</div><div>; sh spm/install.sh src
</div><div>
</div><div>the user interface of SPM Linux is very simple
</div><div>press "super" (mod+mod) or "alt+space" to show the application launcher
</div><div>the first item in application launcher is "system", which opens the system menu:
</div><div>, session (lock, suspend, exit, reboot, poweroff)
</div><div>, connections
</div><div>, timezone
</div><div>, passwords
</div><div>, packages (install, remove, upgrade, install SPM Linux)
</div><div>if the text entered in the system menu, contains a space, it'll be run in a terminal emulator box
</div><div>	the box will be accessible as a system menu entry labeled with a number followed by the entered command
</div><div>	to close the box, and remove its entry, press escape
</div><div>when entering an app name in app launcher, inserting a number sets the selected app,
</div><div>	as the favorite app with the rank equal to the insertd number
</div><div>	inserting zero removes the app from the list of favorite apps
</div><div>"super+space" or "alt+tab" cycles through favorite apps (while the modifier key is pressed)
</div><div>	"super+alphabetic" or "alt+a" or "alt+s" or "alt+q" does the cycle, in two steps
</div><div>	you can combine them to reach the desired app faster
</div><div>"super+enter" or "alt+`" cycles through windows of an app
</div><div>to close focused window, press "super+backspace" or "alt+escape"
</div><div>
</div><div>updating packages is an atomic process
</div><div>nonetheless, to have a really fail'safe system, redundant backups are necessary
</div><div>so make sure to have an extra SPM Linux installed on a removable storage device
</div><div>	system -&gt packages -&gt install SPM Linux
</div><div>
</div><div>to run a program as root:
</div><div>; sudo &ltcommand&gt
</div>
</body></html>
