<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<title>UPM</title>
<link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css'>
<style>
body {
	padding: 4px;
	margin: 0;
	font-family: Hack;
	font-size: 11ppt;
	color: #222222;
	white-space: pre;
	tab-size: 4;
}
</style>
</head><body><a href='https://github.com/damoonsaghian/UPM'><h1>UPM</h1></a>
<h2>1, computers</h2><div>computers can help people to easily access and improve human knowledge,
</div><div>	and as a result do things to improve the quality of human life
</div><div>
</div><div>an ideal computer would be a combination of a smart'phone and a PC
</div><div>, in smart'phone mode, CPU works in cool mode, which doesn't need a fan
</div><div>, in PC mode, it will be put on a cooler
</div><div>the computer itself contains CPU, RAM, SSD, TPM2, Bluetooth, and a USB4 2.0 port that will connect to a hub
</div><div>the hub provides:
</div><div>, power, powerful GPU and WiFi
</div><div>, a USB dock (to connect peripherals like display, camera ...)
</div><div>, compatibility ports for older devices: ethernet, audio jack, DP and HDMI
</div><div>to act as a smart'phone it also has battery, integrated GPU, a small display, camera, speaker, microphone, WiFi and cell
</div><div>during boot, the integrated GPU is used, to prevent any vulnerability due to the OptionROM of external GPU
</div><div>
</div><div><b>the ideal keyboard</b>
</div><div><img src="keyboard.png" alt="keyboard.png"/>
</div><div>
</div><div>navigation keys (arrows, page up, page down, home, end, esc), and ctrl/shift/alt based keybindings,
</div><div>	are available by pressing and holding "mod" key
</div><div>pressing one "mod" key while holding the other one, is equivalent to Super key
</div><div>
</div><div>to insert punctuations (in insert mode), press "pun"
</div><div>	after entering a punctuation charactor, it automatically returns to normal mode
</div><div>	unless the "pun" key is still pressed, in which case, it will return to normal mode after releasing "pun"
</div><div>to insert numbers, press and hold "num"
</div><div>
</div><div>pressing and releasing "Fn", sends "Super+L" key press (usually bound to session locking)
</div><div>holding "Fn" and pressing a number eg 1, sends "F1" key
</div><div>
</div><div>to insert capital letters, press comma then press the letter
</div><div>to insert an all capital word, press two commas
</div><div>	the following letters will be inserted in capitalized form, until space is pressed
</div><div>this is how it is implemented:
</div><div>when comma key is pressed, keyboard enters the cap mode in which:
</div><div>, pressing a letter key, sends a "backspace" key, and then the capitalized form of that letter,
</div><div>	and then the cap mode will be canceled
</div><div>, pressing comma again, sends a "backspace" key, and activates caps mode,
</div><div>	which remains active until space (or enter or mod) is pressed
</div><div>, pressing any other keys, acts like normal, and cancels the cap mode
</div><div>
</div><div><a href="https://jasoncarloscox.com/writing/my-strange-keyboards/">https://jasoncarloscox.com/writing/my-strange-keyboards/</a>
</div><div>	<a href="https://jasoncarloscox.com/creations/kyria/">https://jasoncarloscox.com/creations/kyria/</a>
</div><div>	<a href="https://jasoncarloscox.com/creations/lego-keyboard-stand/">https://jasoncarloscox.com/creations/lego-keyboard-stand/</a>
</div><div><a href="https://splitkb.com/">https://splitkb.com/</a>
</div><div><a href="https://shop.keyboard.io/">https://shop.keyboard.io/</a>
</div><div><a href="https://github.com/abstracthat/dactyl-manuform">https://github.com/abstracthat/dactyl-manuform</a>
</div><div><a href="https://zealot.hu/absolem/">https://zealot.hu/absolem/</a>
</div><div><a href="https://github.com/foostan/crkbd">https://github.com/foostan/crkbd</a>
</div><div><a href="https://github.com/nglgzz/42">https://github.com/nglgzz/42</a>
</div><div><a href="https://github.com/adereth/dactyl-keyboard">https://github.com/adereth/dactyl-keyboard</a>
</div><div>Kinesis Advantage 2 keyboard
</div><div><a href="http://www.allthingsergo.com/the-best-ergonomic-mechanical-keyboards/">http://www.allthingsergo.com/the-best-ergonomic-mechanical-keyboards/</a>
</div><div>
</div><div><b>digital circuits</b>
</div><div>in conventional digital circuits when the inputs change, the outputs can have temporary invalid values,
</div><div>	until they stabilize to the valid values
</div><div>but for the circuit to do its job, gates with memory (registers),
</div><div>	must operate only when the inputs have correct values
</div><div>one solution is to synchronize registers with a global clock signal
</div><div>	the period of clock signal is made long enough for the circuit to become stable
</div><div>
</div><div>disadvantages of synchronous circuits:
</div><div>, we have to split long operations into several smaller ones,
</div><div>	which can be performed in successive clock cycles (a technique known as pipelining)
</div><div>	otherwise the circuit would be slow and inefficient
</div><div>, distributing a high'fan'out, timing'sensitive clock signal can be complicated
</div><div>, electromagnetic interference at the clock frequency and its harmonics
</div><div>, widely distributed clock signal takes a lot of power, and must run whether the circuit is receiving inputs or not
</div><div>although "clock gating" can help to reduce some of the problems of synchronous circuits,
</div><div>	i think the real solution is to use asynchronous circuits
</div><div>
</div><div>the only sane kind of asynchronous circuit which i could imagine is this:
</div><div>, next to any data wire, there is a control wire which determines if the data is valid or not
</div><div>, when a register wants to change its outputs, it first invalidates them,
</div><div>	for a duration equal to the delay of one gate
</div><div>, any gate receiving an invalid input, invalidates its outputs
</div><div>, this way all data which is going to change in the future, is first invalidated
</div><div>, registers operate only when all inputs are valid
</div><div>
</div><div><b>computer architecture</b>
</div><div>cpu, memory, peripherals, this seems to be the only practical architecture for the hardware of computers
</div><div>cpu runs a sequence of simple computations, called instruction codes, one by one
</div><div>compilers are special programs that generate instruction codes,
</div><div>	from a program written in a structured and human readable language
</div><div><a href="https://www.bottomupcs.com/">https://www.bottomupcs.com/</a>
</div><div>
</div><div>backdoors are always a possibility for closed'source CPU with closed'source boot firmware
</div><div>specially after the introduction of "trusted execution environment" (TEE) in the boot firmwares
</div><div>TEE is a full'blown, always'running mini operating system,
</div><div>	with full access to the whole system (including memory and network)
</div><div>furthermore they have made it practically impossible for users to disable it
</div><div>this mess of a design cries out for hidden and quite sophisticated backdoors
</div><div><a href="https://www.fsf.org/blogs/licensing/intel-me-and-why-we-should-get-rid-of-me">https://www.fsf.org/blogs/licensing/intel-me-and-why-we-should-get-rid-of-me</a>
</div><div><a href="https://libreboot.org/faq.html#intel">https://libreboot.org/faq.html#intel</a>
</div><div><a href="https://en.wikipedia.org/wiki/Intel_Management_Engine">https://en.wikipedia.org/wiki/Intel_Management_Engine</a>
</div><div><a href="https://blog.invisiblethings.org/papers/2015/x86_harmful.pdf">https://blog.invisiblethings.org/papers/2015/x86_harmful.pdf</a>
</div><div>
</div><div>in the case of X86 architecture, the default boot firmware of nearly all systems are closed source
</div><div>flashing a CoreBoot based boot firmware is possible, but there still will be closed source parts (Intel FSP)
</div><div>in addition, there is no easy way to get rid of the TEE part, ie Intel ME (or AMD PSP),
</div><div>	though there are some hacks to disable (but not completely remove) it:
</div><div>	<a href="https://puri.sm/posts/deep-dive-into-intel-me-disablement/">https://puri.sm/posts/deep-dive-into-intel-me-disablement/</a>
</div><div>
</div><div>ARM architecture is closed source too, but some vendors (eg Rockchip) use an open source boot firmware (EDK2)
</div><div>there is even an open source implementation of ARM TrustZone: <a href="https://www.trustedfirmware.org/projects/op-tee/">https://www.trustedfirmware.org/projects/op-tee/</a>
</div><div>GPU with open source driver: Qualcomm/Adreno
</div><div>
</div><div>open source CPU: RISC-V, Power ISA
</div><div>
</div><div>programs usually do not run directly on computer hardware
</div><div>instead they run on a more sophisticated software machine (a virtual machine) called the kernel
</div><div>in theory we can live without a kernel (an idea sometimes called a library operating system),
</div><div>	and it can be useful for some use cases (like embedded systems),
</div><div>	but a kernel based operating system makes developing and testing programs, much easier
</div><div>Linux is a highly developed, constantly evolving, open'source kernel
</div>
<h2>2, UPM</h2><div>UPM (unified package manager) uses a simple method to unify software building and package management
</div><div>
</div><div>UPM is still a work in progress
</div><div>meanwhile we can use Alpine Linux to implement a prototype of UPM
</div><div>first we must create a bootable installer on a removable storage device
</div><div>for that, we just need to be in a Linux system, and run the following command (as root):
</div><div>; sh alpine/mkinst.sh
</div><div>now boot into the installation media, and follow the instructions
</div><div>it provides a user interface based on UShell and Codev
</div><div>
</div><div>UPM Linux is a Linux based operating system, built and maintained using UPM
</div><div>to install UPM Linux, first we must create a bootable installer, on a removable storage device
</div><div>to do that, we must be in a Linux system with these programs installed:
</div><div>	gnunet (or curl) mkfs.vfat (dosfstools) mkfs.btrfs (btrfs-progs) cryptsetup tpm2-tools
</div><div>to bootstrap from source, these extra programs are required too:
</div><div>	clang git ssh-keygen
</div><div>now just run this command as root:
</div><div>; sh linux/upm/mkinst.sh
</div><div>note that UPM will try to download binary packages (instead of building from source),
</div><div>	if they are available for your system
</div><div>if you want to make sure that packages are always built from source, run this instead (agian as root):
</div><div>; sh linux/upm/mkinst.sh src
</div><div>this will install a minimal Linux based operating system, running Codev inside Ushell
</div><div>
</div><div>UPM (when ready) by itself can be used as a standalone build system and package manager on any Posix system
</div><div>you just need to have either "gnunet" or "curl" on your system
</div><div>in addition, to bootstrap from source, these extra programs are required too:
</div><div>	clang git ssh-keygen
</div><div>now just run this command to install UPM in user's home directory:
</div><div>; sh linux/upm/new.sh
</div><div>or to build packages from source:
</div><div>; sh linux/upm/new.sh src
</div>
<h2>3, UShell</h2><div>UShell is a Wayland shell, based on QuickShell (<a href="https://quickshell.org/">https://quickshell.org/</a>)
</div><div>
</div><div>there is an application launcher which can be toggled by pressing "super" (mod+mod) or "alt+tab"
</div><div>applications will be opened in their own workspace,	that will also contain any extra windows opened by that application
</div><div>to close the focused window, press "super+backspace" or "alt+escape"
</div><div>
</div><div>entering "space" as the first character in application launcher, opens terminal emulator
</div><div>the entered command will be run in a new terminal view, inside a list at the right column
</div><div>when terminal view finishes its job, if there is any output, it'll be transfered to the history list under the prompt
</div><div>to navigate between terminal views, use "ctrl+pageup" and "ctrl+pagedown" keys
</div><div>to go back to the prompt, press "ctrl+tab"
</div><div>to navigate in history list, use "up" and "down" arrow keys
</div><div>	you can press enter on an entry to rerun the command, or press space to first edit it
</div><div>to close a terminal view (that will also kill any running process) press "super+backspace" or "alt+escape"
</div><div>
</div><div>the first item in the application launcher is "system", which opens the system menu:
</div><div>, session (lock, suspend, exit, reboot, poweroff)
</div><div>, connections
</div><div>, timezone
</div><div>, passwords
</div><div>, packages (install, remove, update, make installation media)
</div><div>, backup (create, restore)
</div><div>
</div><div>packages will be updated automatically
</div><div>this is safe, since the process of updating packages is atomic
</div><div>nonetheless, to have a really fail'safe system, redundant systems are necessary
</div><div>
</div><div>you can create a backup on a removable storage device
</div><div>backups will be done using "BTRFS send", so they will be incremental and fast
</div><div>the backup device is encrypted, and contains a backup of your home directory
</div><div>	dencryption can be done using a password, as well as a key stored on the computer
</div><div>each time the device is connected, the backup procedure will be run automatically
</div><div>even in case of bit rot for data in home directory, this procedure repairs it automatically
</div><div>this backup can be easily restored on a new system
</div><div>these systems will then form an F2F network using GNUnet, through which they will be synced to each other
</div>
</body></html>
